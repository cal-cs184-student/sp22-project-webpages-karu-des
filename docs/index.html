<!DOCTYPE html>
<html>
<head>
<title>writeup.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="project-2-write-up">Project 2 Write-Up</h1>
<h2 id="overview">Overview</h2>
<p>As the title of the project implies, in this project we wrote several algorithms
to deal with meshes, specifically in an editor. After completing this project
we are able to take meshes and display Bezier curves and surfaces, see meshes
with vertex normals for shading, flip edges, split edges, and perform loop subdivision
on meshes. Dealing with vertex and edge updates was a very interesting aspect of
this assignment. Figuring out how to debug things made this project unique to ones
I have worked on in the past.</p>
<h2 id="part-1">Part 1</h2>
<p>Casteljau's algorithm essentially takes a set of points and a value t and
recursively linearly interpolates between points until there is only one point
left. The implementation for this is very straightforward, using a for loop to
go through all sets of adjacent points and finding the intermediate points for
a step. Then evaluating the step multiple times gets us the result that we want.</p>
<h3 id="6-original-points-curve-and-final-evaluated-points">6 Original Points, Curve and Final Evaluated Points</h3>
<img src="../proj2/images/part1-1.png" width="400"/>
<img src="../proj2/images/part1-2.png" width="400"/>
<img src="../proj2/images/part1-8.png" width="400"/>
<h3 id="each-step-of-casteljaus-algorithm">Each step of Casteljau's Algorithm</h3>
<img src="../proj2/images/part1-3.png" width="400"/>
<img src="../proj2/images/part1-4.png" width="400"/>
<img src="../proj2/images/part1-5.png" width="400"/>
<img src="../proj2/images/part1-6.png" width="400"/>
<img src="../proj2/images/part1-7.png" width="400"/>
<br>
<h3 id="slightly-different-curve-with-different-t-value">Slightly different curve with different t value</h3>
<img src="../proj2/images/part1-9.png" width="400"/>
<img src="../proj2/images/part1-10.png" width="400"/>
<h2 id="part-2">Part 2</h2>
<p>Casteljau's algorithm extends to Bezier surfaces by basically splitting the
control points of the surface into rows and columns, finding the final single
point along each row using v as the value for t, and then finding the final
single point along the column using the points of each row and u as the value
for t. The implementation required was fairly straightforward, writing a helper
function to do 1 step of Casteljau's algorithm and then another helper function
to get the final single point using recursion. Finally we could evaluate using
the control points and the values of u and v plugging things into the helper
functions to get our final point.</p>
<h3 id="screenshot-of-bezteapotbez">Screenshot of <code>bez/teapot.bez</code></h3>
<img src="../proj2/images/part2.png" width="600">
<h2 id="part-3">Part 3</h2>
<p>The implementation for area-weighted vertex normals was fairly straightforward.
I looped through every single face that had the Vertex as a part of it using
halfedge traversal. At each face I found the 3 vertices and used that to
calculate the normal vector as well as the area. Then I added the normal vector
weighted by the area to the final result vector. Finally, once I had traversed
through all faces I returned the result as a normalized unit vector.</p>
<h3 id="screenshot-of-daeteapotdae-without-vertex-normals-left-and-with-vertex-normals-right">Screenshot of <code>dae/teapot.dae</code> without vertex normals (left) and with vertex normals (right)</h3>
<img src="../proj2/images/part3-1.png" width="500"/>
<img src="../proj2/images/part3-2.png" width="500"/>
<h2 id="part-4">Part 4</h2>
<p>The way I implemented the edge flip operation is by first drawing and listing
out every single element in a pair of adjacent triangles. Then I also drew the
same thing for after the edge flip. I labeled each element in a consistent way
that I would also be able to easily keep track of in code. I then determined
how each element changed before and after the edge flip. Figuring this out I
was able to then go and make all of those changes to each element as necessary.
Because of how thorough I was with drawing and preparing before writing any
code, I did not have to do any debugging.</p>
<h3 id="screenshot-of-daeteapotdae-normally-left-and-with-some-edge-flips-right">Screenshot of <code>dae/teapot.dae</code> normally (left) and with some edge flips (right)</h3>
<img src="../proj2/images/part4-1.png" width="500"/>
<img src="../proj2/images/part4-2.png" width="500"/>
<h2 id="part-5">Part 5</h2>
<p>The way I implemented the edge split operation is very similar to the edge flip
operation. I listed out every single element before and after the split, making
sure to keep track of what elements were old and which ones were new. Then
having labeled them in a consistent way that I would be able to keep track of I
went and got all the elements as well as created all the new elements, making
sure to go through and assign each aspect of the element in the code. Because
of the way I wrote everything down before writing any code, I only had one
small error that was due to a typo. I was able to quickly find and fix the error
without any major debugging issues.</p>
<h3 id="screenshot-of-daeteapotdae-normally-left-with-some-edge-splits-middle-and-with-some-edge-splits-and-flips-right">Screenshot of <code>dae/teapot.dae</code> normally (left), with some edge splits (middle), and with some edge splits and flips (right)</h3>
<img src="../proj2/images/part5-1.png" width="400"/>
<img src="../proj2/images/part5-2.png" width="400"/>
<img src="../proj2/images/part5-3.png" width="400"/>
<h2 id="part-6">Part 6</h2>
<p>When implementing loop subdivision I mainly followed the outline given to us in
the comments of the method. At first I had trouble fully understanding what
exactly each step was meant to do, and I had vertex computation done in a way
such that I thought that edge vertex computation would not be necessary.
Eventually I realized that this doesn't work mainly because the first iteration
will always have problems, and that all iterations would have issues with
assigning positions to newly created vertices. I also had an issue where I was
splitting too many edges and accidentally splitting edges that had just been
created. I found this out by simply printing out the number of edges before and
after the splitting operation. For the <code>cube.dae</code> I noticed that the first
iteration started with 18 edges and ended up with 75 edges post splitting. This
is obviously wrong because each split should only create 3 new edges, resulting
in 54 new edges and a total of 72 edges. The way I resolved this is by using a
count of edges instead of <code>edge-&gt;isnew</code>.
<br>
It is very obvious that with loop subdivision, meshes become more defined and
generally &quot;smoother&quot; in a sense. An example of such smoothing can be seen below.</p>
<h3 id="screenshot-of-daeteapotdae-normally-left-and-with-one-loop-subdivision-right">Screenshot of <code>dae/teapot.dae</code> normally (left) and with one loop subdivision (right)</h3>
<img src="../proj2/images/part6-1.png" width="500"/>
<img src="../proj2/images/part6-2.png" width="500"/>
<br>
<br>
Additionally we notice that for the cube, it begins to become asymmetric after 
repeated subdivisions. The reason for this, is that there only exists one edge
along the diagonals. However we can fix this by preprocessing the cube. If we
split each diagonal edge before performing subdivisions we end up with a cube
that divides symmetrically. The reason this works is because the splits happen 
evenly without any weird randomness in splitting order effecting how the cube divides.
<h3 id="screenshot-of-daecubedae-with-preprocessing-and-3-layers-of-loop-subdivision-left-to-right">Screenshot of <code>dae/cube.dae</code> with preprocessing and 3 layers of loop subdivision (left to right)</h3>
<img src="../proj2/images/part6-3.png" width="300"/>
<img src="../proj2/images/part6-4.png" width="300"/>
<img src="../proj2/images/part6-5.png" width="300"/>
<img src="../proj2/images/part6-6.png" width="300"/>
</body>
</html>
